<!DOCTYPE html>
<html lang="nl">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Sudoku ‚Äî Volledig Interactief</title>
  <style>
    :root {
      --bg: #0f172a;
      --panel: #111827;
      --panel-2: #1f2937;
      --text: #e5e7eb;
      --muted: #94a3b8;
      --accent: #60a5fa;
      --accent-2: #22d3ee;
      --given: #cbd5e1;
      --grid: #334155;
      --grid-strong: #cbd5e1;
      --numpad-bg: #1e293b;
      --numpad-hover: #233149;
      --numpad-text: var(--text);
      --highlight-bg: rgba(250,204,21,0.36);
      --highlight-text: #071428;
    }
    * { box-sizing: border-box; }
    html, body { height: 100%; }
    body {
      margin: 0; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
      color: var(--text); background: radial-gradient(1200px 800px at 20% -10%, #1e293b, #0b1222), var(--bg);
      display: grid; place-items: center; padding: 16px;
    }
    .app { width: min(1100px, 96vw); display: grid; grid-template-columns: 1fr 340px; gap: 18px; }
    @media (max-width: 980px){ .app { grid-template-columns: 1fr; } }

    .card { background: linear-gradient(180deg, rgba(255,255,255,0.04), rgba(255,255,255,0.02));
            border: 1px solid rgba(255,255,255,0.08); border-radius: 18px; box-shadow: 0 20px 40px rgba(0,0,0,0.35); backdrop-filter: blur(6px); }
    .board-wrap { padding: 14px; }

    .board { width: min(78vmin, 720px); aspect-ratio: 1 / 1; margin: 0 auto;
      display: grid; grid-template-columns: repeat(9, 1fr); grid-template-rows: repeat(9, 1fr);
      background: var(--panel); border-radius: 12px; overflow: hidden; position: relative; border: 2px solid var(--grid-strong); }

    .cell { position: relative; border-right: 1px solid var(--grid); border-bottom: 1px solid var(--grid);
      display: grid; place-items: center; font-weight: 600; cursor: pointer; user-select: none; transition: background 120ms ease, color 120ms ease, transform 80ms; font-size: clamp(16px, 3.2vmin, 28px); }
    .cell:nth-child(9n) { border-right: none; }
    .cell:nth-child(n+73) { border-bottom: none; }

    .cell[data-r="2"], .cell[data-r="5"] { border-bottom: 2px solid var(--grid-strong)!important; }
    .cell[data-c="2"], .cell[data-c="5"] { border-right: 2px solid var(--grid-strong)!important; }

    .val { position: relative; z-index: 1; }
    .given { color: var(--given); }
    .selected { background: rgba(96, 165, 250, 0.18); }
    .peer { background: rgba(148, 163, 184, 0.10); }
    .same { color: var(--highlight-text); background: var(--highlight-bg); font-weight: 800; }
    .conflict { background: rgba(239, 68, 68, 0.18)!important; }
    .shake { animation: shake 220ms linear; }
    @keyframes shake { 0%, 100% { transform: translateX(0); } 25% { transform: translateX(-3px);} 75% { transform: translateX(3px);} }
    .error { background: rgba(239, 68, 68, 0.75)!important; }

    .notes { position: absolute; inset: 2px; display: grid; grid-template-columns: repeat(3, 1fr); grid-template-rows: repeat(3, 1fr); gap: 1px; font-size: clamp(8px, 1.4vmin, 12px); color: var(--muted); pointer-events: none; z-index: 0; }
    .note { display: grid; place-items: center; opacity: 0.9; border-radius: 4px; }
    .note.same-note { background: var(--highlight-bg); color: var(--highlight-text); font-weight: 800; }

    .side { padding: 16px; display: grid; gap: 14px; }
    .row { display: flex; gap: 10px; align-items: center; flex-wrap: wrap; }
    .title { font-size: 20px; font-weight: 700; letter-spacing: 0.2px; }

    .btn { background: var(--panel-2); border: 1px solid rgba(255,255,255,0.08); color: var(--text);
           border-radius: 12px; padding: 12px 14px; cursor: pointer; font-weight: 600; transition: transform 80ms, background 120ms, border 120ms; }
    .btn:hover { background: #273244; }
    .btn:active { transform: translateY(1px); }
    .btn.primary { background: linear-gradient(135deg, rgba(96,165,250,0.25), rgba(34,211,238,0.18)); border: 1px solid rgba(96,165,250,0.4); }
    .btn.warn { background: linear-gradient(135deg, rgba(245,158,11,0.18), rgba(245,158,11,0.08)); border: 1px solid rgba(245,158,11,0.35); }
    .btn.danger { background: linear-gradient(135deg, rgba(239,68,68,0.18), rgba(239,68,68,0.08)); border: 1px solid rgba(239,68,68,0.35); }

    .numpad { display: grid; grid-template-columns: repeat(5, 1fr); gap: 8px; }
    .num { padding: 16px 0; border-radius: 12px; font-size: 18px; font-weight: 800; text-align: center; background: var(--numpad-bg); border: 1px solid rgba(255,255,255,0.06); color: var(--numpad-text); cursor: pointer; }
    .num:hover { background: var(--numpad-hover); }
    .num.active { outline: 2px solid var(--accent); }

    .stats { display: grid; grid-template-columns: repeat(3, 1fr); gap: 8px; }
    .stat { background: var(--panel-2); border: 1px solid rgba(255,255,255,0.08); border-radius: 12px; padding: 10px; text-align: center; }
    .stat label { display:block; font-size: 12px; color: var(--muted); }
    .stat strong { font-size: 18px; }

    .footer { text-align: center; color: var(--muted); font-size: 12px; padding: 2px 0 8px; }
    a { color: var(--accent); text-decoration: none; }
  </style>
</head>
<body>
  <div class="app">
    <div class="card board-wrap">
      <div class="board" id="board" aria-label="Sudoku bord" role="grid"></div>
    </div>

    <aside class="card side" aria-label="Bediening">
      <div class="title">Sudoku</div>
      <div class="row">
        <button class="btn primary" id="newEasy">Nieuwe puzzel (Makkelijk)</button>
        <button class="btn primary" id="newHard">Nieuwe puzzel (Moeilijk)</button>
      </div>
      <ul>
        <li><a href="index.html">TERUG NAAR VORIGEEEEEEEEEE</a></li>
      </ul>
      <div class="row">
        <button class="btn" id="undoBtn" title="Ongedaan maken">‚Ü∂ Undo</button>
        <button class="btn" id="redoBtn" title="Opnieuw">‚Ü∑ Redo</button>
        <button class="btn warn" id="noteToggle" title="Notitiemodus">üìù Notities: <span id="noteState">UIT</span></button>
        <button class="btn" id="autoNotesToggle" title="Auto-kandidaten">‚öôÔ∏è Auto-notes: <span id="autoNoteState">AAN</span></button>
        <button class="btn" id="themeToggle" title="Thema wisselen">üåì Thema</button>
        <button class="btn" id="hintBtn" title="Hint (vult een logische kandidaat)">üí° Hint</button>
      </div>

      <div class="numpad" id="numpad" aria-label="Numpad voor invoer">
        <div class="num" data-n="1">1</div>
        <div class="num" data-n="2">2</div>
        <div class="num" data-n="3">3</div>
        <div class="num" data-n="4">4</div>
        <div class="num" data-n="5">5</div>
        <div class="num" data-n="6">6</div>
        <div class="num" data-n="7">7</div>
        <div class="num" data-n="8">8</div>
        <div class="num" data-n="9">9</div>
        <div class="num" data-n="E">‚å´</div>
      </div>

      <div class="stats">
        <div class="stat"><label>Tijd</label><strong id="time">00:00</strong></div>
        <div class="stat"><label>Fouten</label><strong id="mistakes">0</strong></div>
        <div class="stat"><label>Veld</label><strong id="sel">‚Äî</strong></div>
      </div>

      <div class="row">
        <select class="btn" id="puzzleSelect" title="Kies puzzel">
          <option value="easy-0">Voorbeeld Easy #1</option>
          <option value="easy-1">Voorbeeld Easy #2</option>
          <option value="easy-2">Voorbeeld Easy #3</option>
          <option value="medium-0">Voorbeeld Medium #1</option>
          <option value="medium-1">Voorbeeld Medium #2</option>
          <option value="hard-0">Voorbeeld Hard #1</option>
          <option value="expert-0">Voorbeeld Expert #1</option>
        </select>
        <button class="btn" id="loadSelected">Laden</button>
        <button class="btn danger" id="resetBtn">Reset</button>
      </div>
      <div class="footer">Volledig client-side. Sleep dit HTML-bestand naar je hosting en klaar. ‚ú®</div>
    </aside>
  </div>

  <script>
  // ======= Utility helpers =======
  const byId = (id) => document.getElementById(id);
  const boardEl = byId('board');
  const numpadEl = byId('numpad');
  const timeEl = byId('time');
  const mistakesEl = byId('mistakes');
  const selEl = byId('sel');
  const noteToggle = byId('noteToggle');
  const noteState = byId('noteState');
  const autoNotesToggle = byId('autoNotesToggle');
  const autoNoteState = byId('autoNoteState');
  const themeToggle = byId('themeToggle');
  const undoBtn = byId('undoBtn');
  const redoBtn = byId('redoBtn');

  // ======= Game State =======
  const State = {
    puzzle: new Array(81).fill(0),
    fixed:  new Array(81).fill(false),
    grid:   new Array(81).fill(0),
    // notes: manual notes created by the user (persist across toggles)
    notes:  Array.from({length:81}, () => new Set()),
    // autoCandidates: computed candidates when autoNotes is on (kept separate)
    autoCandidates: Array.from({length:81}, () => new Set()),
    selected: -1,
    noteMode: false,
    mistakes: 0,
    timerStart: null,
    elapsed: 0,
    history: [],
    future: [],
    autoNotes: true,
    highlightDigit: 0,
  };

  // ======= Puzzles =======
  const PUZZLES = {
    easy: [
      '530070000600195000098000060800060003400803001700020006060000280000419005000080079',
      '200080300060070084030500209000105408000000000402706000301007040720040060004010003',
      '003020600900305001001806400008102900700000008006708200002609500800203009005010300',
      '400000805030000000000700000020000060000080400000010000000603070500200000104000000'
    ],
    medium: [
      '000260701680070090190004500820100040004602900050003028009300074040050036703018000',
      '000000000009050200000107000706030400020000060004090801000401000002060700000000000',
      '060000200000031040403000000000907000000000000000403000000000506050000000001000030'
    ],
    hard: [
      '000000907000420180000705026100904000050000040000507009920108000034059000507000000',
      '005300000800000020070010500400005300010070006003200004060000050000040000000000000',
      '300200000000107000706030500070009080900020004010800050009040301000702000000008006'
    ],
    expert: [
      '800000000003600000070090200050007000000045700000100030001000068008500010090000400',
      '000900000050000003030000070000050004007000800600030000080000020100000030000008000'
    ]
  };

  // ======= Build Board =======
  function buildBoard(){
    boardEl.innerHTML = '';
    for(let r=0; r<9; r++){
      for(let c=0; c<9; c++){
        const i = r*9+c;
        const cell = document.createElement('div');
        cell.className = 'cell';
        cell.dataset.i = i; cell.dataset.r = r; cell.dataset.c = c; cell.dataset.b = boxIndex(r,c);
        cell.setAttribute('role','gridcell'); cell.setAttribute('aria-label', `R${r+1} C${c+1}`);
        cell.addEventListener('click', () => selectCell(i));

        const val = document.createElement('div');
        val.className = 'val';

        const notes = document.createElement('div'); notes.className = 'notes';
        for(let n=1; n<=9; n++){ const s=document.createElement('div'); s.className='note'; s.textContent=n; notes.appendChild(s);}        

        cell.appendChild(val);
        cell.appendChild(notes);
        boardEl.appendChild(cell);
      }
    }
  }

  // ======= Helpers =======
  const rowColOf = (i) => [Math.floor(i/9), i%9];
  const boxIndex = (r, c) => Math.floor(r/3)*3 + Math.floor(c/3);

  // ======= Candidates / Notes logic =======
  function candidatesAt(i){
    if(State.grid[i]) return new Set();
    const [r,c] = rowColOf(i);
    const used = new Set();
    for(let k=0;k<9;k++){ used.add(State.grid[r*9+k]); used.add(State.grid[k*9+c]); }
    const br = Math.floor(r/3)*3, bc=Math.floor(c/3)*3;
    for(let dr=0; dr<3; dr++) for(let dc=0; dc<3; dc++) used.add(State.grid[(br+dr)*9+(bc+dc)]);
    const out = new Set();
    for(let n=1;n<=9;n++) if(!used.has(n)) out.add(n);
    return out;
  }

  function recomputeAutoCandidates(){
    for(let i=0;i<81;i++){
      if(State.grid[i]===0){ State.autoCandidates[i] = candidatesAt(i); }
      else { State.autoCandidates[i].clear(); }
    }
  }

  function recomputeNotesIfNeeded(){
    if(State.autoNotes){ recomputeAutoCandidates(); }
  }

  // ======= Rendering =======
  function render(){
    for(let i=0;i<81;i++){
      const cell = boardEl.children[i];
      const v = State.grid[i];
      const valEl = cell.querySelector('.val');
      const notesEl = cell.querySelector('.notes');

      cell.classList.toggle('given', State.fixed[i]);
      valEl.textContent = v ? v : '';

      // Decide which note set to display:
      // - If user has manually added notes (State.notes[i].size > 0), show those.
      // - Else if autoNotes is enabled and noteMode is ON, show autoCandidates.
      const manual = State.notes[i];
      const autoC = State.autoCandidates[i];
      const hasManual = manual && manual.size>0;
      const showSet = hasManual ? manual : (State.noteMode ? (State.autoNotes ? autoC : new Set()) : new Set());

      // visibility: show notes when cell is empty AND (there are manual notes OR noteMode is ON)
      const showVisible = (v===0) && (hasManual || State.noteMode);
      notesEl.style.display = showVisible ? 'grid' : 'none';

      const children = notesEl.children;
      for(let n=1;n<=9;n++){
        const noteEl = children[n-1];
        noteEl.style.opacity = showSet.has(n) ? 1 : 0;
        noteEl.classList.remove('same-note');
      }
      cell.classList.remove('selected', 'peer', 'same', 'conflict', 'error');
    }

    // highlights
    const hd = State.highlightDigit;
    if(State.selected !== -1){
      const [sr, sc] = rowColOf(State.selected);
      for(let i=0; i<81; i++){
        const cell = boardEl.children[i];
        const [r,c] = rowColOf(i);
        if(r===sr || c===sc || boxIndex(r,c)===boxIndex(sr,sc)) cell.classList.add('peer');
      }
      boardEl.children[State.selected].classList.add('selected');
    }

    // highlight same numbers and notes
    let val = 0;
    if(State.selected !== -1) val = State.grid[State.selected];
    const target = hd || val;
    if(target){
      for(let i=0;i<81;i++){
        const cell = boardEl.children[i];
        if(State.grid[i]===target) cell.classList.add('same');
        // notes highlight: highlight manual notes if present, otherwise autoCandidates if shown
        const notesEl = cell.querySelector('.notes');
        if(notesEl && notesEl.style.display !== 'none'){
          const manual = State.notes[i];
          const autoC = State.autoCandidates[i];
          const showSet = (manual && manual.size>0) ? manual : (State.autoNotes ? autoC : new Set());
          const child = notesEl.children[target-1];
          if(child && showSet.has(target)) child.classList.add('same-note');
        }
      }
    }

    const conflicts = computeConflicts();
    conflicts.forEach(i => boardEl.children[i].classList.add('conflict'));

    mistakesEl.textContent = State.mistakes;
    noteState.textContent = State.noteMode ? 'AAN' : 'UIT';
    autoNoteState.textContent = State.autoNotes ? 'AAN' : 'UIT';
  }

  // ======= Game logic =======
  function computeConflicts(){
    const bad = new Set();
    for(let r=0; r<9; r++){ const seen = {}; for(let c=0;c<9;c++){ const i=r*9+c; const v=State.grid[i]; if(!v) continue; if(seen[v]!==undefined){ bad.add(i); bad.add(seen[v]); } else seen[v]=i; }}
    for(let c=0; c<9; c++){ const seen = {}; for(let r=0;r<9;r++){ const i=r*9+c; const v=State.grid[i]; if(!v) continue; if(seen[v]!==undefined){ bad.add(i); bad.add(seen[v]); } else seen[v]=i; }}
    for(let br=0;br<3;br++) for(let bc=0;bc<3;bc++){ const seen={}; for(let dr=0;dr<3;dr++) for(let dc=0;dc<3;dc++){ const r=br*3+dr, c=bc*3+dc, i=r*9+c; const v=State.grid[i]; if(!v) continue; if(seen[v]!==undefined){ bad.add(i); bad.add(seen[v]); } else seen[v]=i; }}
    return bad;
  }

  function selectCell(i){
    State.selected = i;
    if(State.grid[i] && !State.highlightDigit) State.highlightDigit = State.grid[i];
    render();
  }

  function pushHistory(action){ State.history.push(action); State.future.length = 0; }
  function doSetNumber(i, n){
    const prev = State.grid[i];
    if(State.fixed[i]) return false;
    if(n===0){
      pushHistory({type:'set', i, from: prev, to: 0, notesBefore: new Set(State.notes[i])});
      State.grid[i]=0;
      return true;
    }
    if(!isLegal(i,n)){
      State.mistakes++;
      flashIllegal(i);
      return false;
    }
    // record manual notes snapshot for history (for the touched cell)
    pushHistory({type:'set', i, from: prev, to: n, notesBefore: new Set(State.notes[i])});

    State.grid[i]=n;
    // clear manual notes in this cell
    State.notes[i].clear();

    // ALSO: remove this digit (n) from manual notes in all peers (same row, col, box)
    const [r,c] = rowColOf(i);
    // row
    for(let cc=0; cc<9; cc++){
      const idx = r*9 + cc;
      if(idx===i) continue;
      if(State.notes[idx].has(n)) State.notes[idx].delete(n);
    }
    // column
    for(let rr=0; rr<9; rr++){
      const idx = rr*9 + c;
      if(idx===i) continue;
      if(State.notes[idx].has(n)) State.notes[idx].delete(n);
    }
    // box
    const br = Math.floor(r/3)*3, bc = Math.floor(c/3)*3;
    for(let dr=0; dr<3; dr++) for(let dc=0; dc<3; dc++){
      const idx = (br+dr)*9 + (bc+dc);
      if(idx===i) continue;
      if(State.notes[idx].has(n)) State.notes[idx].delete(n);
    }

    // recompute auto candidates and update UI
    recomputeNotesIfNeeded();
    State.highlightDigit = 0;
    return true;
  }

  function isLegal(i,n){ const [r,c]=rowColOf(i); for(let k=0;k<9;k++){ if(State.grid[r*9+k]===n) return false; if(State.grid[k*9+c]===n) return false;} const br=Math.floor(r/3)*3, bc=Math.floor(c/3)*3; for(let dr=0;dr<3;dr++) for(let dc=0;dc<3;dc++) if(State.grid[(br+dr)*9+(bc+dc)]===n) return false; return true; }

  function flashIllegal(i){ const cell=boardEl.children[i]; cell.classList.add('error'); setTimeout(()=>cell.classList.remove('error'),3000); }

  function undo(){ const a=State.history.pop(); if(!a) return; State.future.push(a); if(a.type==='set'){ State.grid[a.i]=a.from; State.notes[a.i]=new Set(a.notesBefore); } render(); }
  function redo(){ const a=State.future.pop(); if(!a) return; State.history.push(a); if(a.type==='set'){ State.grid[a.i]=a.to; if(a.to!==0) State.notes[a.i].clear(); } render(); }

  // ======= Interactions =======
  numpadEl.addEventListener('click',(e)=>{
    const key = e.target.closest('.num'); if(!key) return;
    const v = key.dataset.n;
    if(v !== 'E' && /^[1-9]$/.test(v)) State.highlightDigit = parseInt(v,10);
    else if(v==='E') State.highlightDigit = 0;

    if(State.selected===-1){ render(); return; }

    if(v==='E'){ if(doSetNumber(State.selected,0)){ recomputeNotesIfNeeded(); render(); checkWin(); } return; }
    const n=parseInt(v,10);
    if(State.noteMode){
      if(State.fixed[State.selected]) return;
      if(State.grid[State.selected]!==0) return;
      // allow manual notes always (even when autoNotes is ON); manual notes persist across toggles
      if(State.notes[State.selected].has(n)) State.notes[State.selected].delete(n); else State.notes[State.selected].add(n);
      render();
    } else {
      if(doSetNumber(State.selected,n)){ recomputeNotesIfNeeded(); render(); checkWin(); }
    }
  });

  noteToggle.addEventListener('click',()=>{
    State.noteMode = !State.noteMode;
    // IMPORTANT: do NOT clear State.notes when toggling. Manual notes must persist.
    // If user turns on noteMode and they had no manual notes, the visible notes come from autoCandidates (if enabled).
    if(State.noteMode && State.autoNotes && State.autoCandidates.every(s=>s.size===0)) recomputeAutoCandidates();
    render();
  });

  autoNotesToggle.addEventListener('click',()=>{ State.autoNotes = !State.autoNotes; if(State.autoNotes) recomputeAutoCandidates(); render(); });
  themeToggle.addEventListener('click',toggleTheme);
  undoBtn.addEventListener('click',undo);
  redoBtn.addEventListener('click',redo);

  window.addEventListener('keydown',(e)=>{
    const allowed=['ArrowUp','ArrowDown','ArrowLeft','ArrowRight','Tab'];
    if(allowed.includes(e.key)){
      if(State.selected===-1) return; e.preventDefault(); const [r,c]=rowColOf(State.selected);
      if(e.key==='ArrowUp'&&r>0) selectCell((r-1)*9+c);
      if(e.key==='ArrowDown'&&r<8) selectCell((r+1)*9+c);
      if(e.key==='ArrowLeft'&&c>0) selectCell(r*9+(c-1));
      if(e.key==='ArrowRight'&&c<8) selectCell(r*9+(c+1));
      return;
    }
    if(/^[1-9]$/.test(e.key)) e.preventDefault();
  });

  // ======= Timer, hints, load/reset =======
  function startTimer(){ State.timerStart=Date.now(); clearInterval(window._tick); window._tick=setInterval(()=>{ const t=Math.floor((Date.now()-State.timerStart+State.elapsed)/1000); const m=String(Math.floor(t/60)).padStart(2,'0'); const s=String(t%60).padStart(2,'0'); timeEl.textContent=`${m}:${s}`; },250);} 
  function stopTimer(){ clearInterval(window._tick); }

  function checkWin(){ for(let i=0;i<81;i++) if(State.grid[i]===0) return false; if(computeConflicts().size===0){ stopTimer(); setTimeout(()=>alert(`üéâ Gefeliciteerd! Opgelost in ${timeEl.textContent} met ${State.mistakes} fouten.`),50); return true;} return false; }

  const hintBtn = byId('hintBtn');
  hintBtn.addEventListener('click',()=>{ recomputeNotesIfNeeded(); for(let i=0;i<81;i++){ if(State.grid[i]===0){ const cand=candidatesAt(i); if(cand.size===1){ const [n]=cand; doSetNumber(i,n); State.selected=i; recomputeNotesIfNeeded(); render(); checkWin(); return; }}} boardEl.classList.add('shake'); setTimeout(()=>boardEl.classList.remove('shake'),250); });

  function loadPuzzle(str){ State.puzzle = Array.from(str).map(ch=>parseInt(ch,10)||0); State.grid = State.puzzle.slice(); State.fixed = State.puzzle.map(v=>v!==0); State.notes = Array.from({length:81},()=>new Set()); State.autoCandidates = Array.from({length:81},()=>new Set()); State.selected=-1; State.mistakes=0; State.history=[]; State.future=[]; State.elapsed=0; startTimer(); if(State.autoNotes) recomputeAutoCandidates(); State.highlightDigit=0; render(); }
  function resetPuzzle(){ State.grid=State.puzzle.slice(); State.notes=Array.from({length:81},()=>new Set()); State.autoCandidates=Array.from({length:81},()=>new Set()); State.selected=-1; State.mistakes=0; State.history=[]; State.future=[]; State.elapsed=0; startTimer(); if(State.autoNotes) recomputeAutoCandidates(); State.highlightDigit=0; render(); }

  byId('newEasy').addEventListener('click',()=>{ const s=PUZZLES.easy[Math.floor(Math.random()*PUZZLES.easy.length)]; loadPuzzle(s); });
  byId('newHard').addEventListener('click',()=>{ const s=PUZZLES.hard[Math.floor(Math.random()*PUZZLES.hard.length)]; loadPuzzle(s); });

  const puzzleSelect = byId('puzzleSelect');
  const loadSelected = byId('loadSelected');
  loadSelected.addEventListener('click',()=>{ const v=puzzleSelect.value; const [diff,idx]=v.split('-'); loadPuzzle(PUZZLES[diff][parseInt(idx,10)]); });
  byId('resetBtn').addEventListener('click', resetPuzzle);

  function applyTheme(theme){ const root=document.documentElement; if(theme==='light'){ root.style.setProperty('--bg','#f3f4f6'); root.style.setProperty('--panel','#ffffff'); root.style.setProperty('--panel-2','#f8fafc'); root.style.setProperty('--text','#0f172a'); root.style.setProperty('--muted','#475569'); root.style.setProperty('--accent','#2563eb'); root.style.setProperty('--accent-2','#0891b2'); root.style.setProperty('--given','#334155'); root.style.setProperty('--grid','#cbd5e1'); root.style.setProperty('--grid-strong','#94a3b8'); root.style.setProperty('--numpad-bg','#f1f5f9'); root.style.setProperty('--numpad-hover','#e2e8f0'); root.style.setProperty('--numpad-text','#0f172a'); root.style.setProperty('--highlight-bg','rgba(250,204,21,0.36)'); root.style.setProperty('--highlight-text','#071428'); document.body.style.background='linear-gradient(180deg,#e2e8f0,#f8fafc)'; } else { root.style.setProperty('--bg','#0f172a'); root.style.setProperty('--panel','#111827'); root.style.setProperty('--panel-2','#1f2937'); root.style.setProperty('--text','#e5e7eb'); root.style.setProperty('--muted','#94a3b8'); root.style.setProperty('--accent','#60a5fa'); root.style.setProperty('--accent-2','#22d3ee'); root.style.setProperty('--given','#cbd5e1'); root.style.setProperty('--grid','#334155'); root.style.setProperty('--grid-strong','#cbd5e1'); root.style.setProperty('--numpad-bg','#1e293b'); root.style.setProperty('--numpad-hover','#233149'); root.style.setProperty('--numpad-text','var(--text)'); root.style.setProperty('--highlight-bg','rgba(250,204,21,0.36)'); root.style.setProperty('--highlight-text','#071428'); document.body.style.background='radial-gradient(1200px 800px at 20% -10%, #1e293b,#0b1222),var(--bg)'; } localStorage.setItem('sudoku-theme',theme); document.querySelectorAll('.num').forEach(n=>{ n.style.background=getComputedStyle(root).getPropertyValue('--numpad-bg'); n.style.color=getComputedStyle(root).getPropertyValue('--numpad-text'); }); }
  function toggleTheme(){ const cur=localStorage.getItem('sudoku-theme')||'dark'; applyTheme(cur==='dark'?'light':'dark'); }

  buildBoard(); applyTheme(localStorage.getItem('sudoku-theme')||'dark'); loadPuzzle(PUZZLES.easy[0]);
  </script>
</body>
</html>
